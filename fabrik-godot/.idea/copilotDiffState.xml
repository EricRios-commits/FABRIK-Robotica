<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/scenes/main.tscn">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scenes/main.tscn" />
              <option name="originalContent" value="[gd_scene load_steps=10 format=3 uid=&quot;uid://pwcja2iwl6ej&quot;]&#10;&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://cwv0n52mn1n0k&quot; path=&quot;res://scenes/main_scene.gd&quot; id=&quot;1_tbgi4&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://cf0ebjoqwsgky&quot; path=&quot;res://core/ik_controller.gd&quot; id=&quot;2_tefeu&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://blys41lg01fyr&quot; path=&quot;res://visualization/chain_visualizer.gd&quot; id=&quot;3_o6xl0&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://bottxwpbkclic&quot; path=&quot;res://visualization/target_visualizer.gd&quot; id=&quot;4_tipki&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://d218u27sl8kf8&quot; path=&quot;res://ui/ik_control_panel.gd&quot; id=&quot;5_85g3d&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://ivj52hx2vhln&quot; path=&quot;res://core/ik_chain.gd&quot; id=&quot;6_tefeu&quot;]&#10;&#10;[sub_resource type=&quot;ProceduralSkyMaterial&quot; id=&quot;ProceduralSkyMaterial_tefeu&quot;]&#10;sky_top_color = Color(0.546, 0.57199997, 0.65, 1)&#10;sky_horizon_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;ground_bottom_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;ground_horizon_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;&#10;[sub_resource type=&quot;Sky&quot; id=&quot;Sky_tefeu&quot;]&#10;sky_material = SubResource(&quot;ProceduralSkyMaterial_tefeu&quot;)&#10;&#10;[sub_resource type=&quot;Environment&quot; id=&quot;Environment_o6xl0&quot;]&#10;background_mode = 2&#10;sky = SubResource(&quot;Sky_tefeu&quot;)&#10;ambient_light_color = Color(1, 1, 1, 1)&#10;&#10;[node name=&quot;Main&quot; type=&quot;Node3D&quot;]&#10;script = ExtResource(&quot;1_tbgi4&quot;)&#10;&#10;[node name=&quot;IKChain&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;6_tefeu&quot;)&#10;metadata/_custom_type_script = &quot;uid://ivj52hx2vhln&quot;&#10;&#10;[node name=&quot;IKController&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;2_tefeu&quot;)&#10;&#10;[node name=&quot;ChainVisualizer&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;3_o6xl0&quot;)&#10;segment_color = Color(1, 1, 0, 1)&#10;&#10;[node name=&quot;TargetVisualizer&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;4_tipki&quot;)&#10;&#10;[node name=&quot;Camera3D&quot; type=&quot;Camera3D&quot; parent=&quot;.&quot;]&#10;transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0.23479745)&#10;projection = 1&#10;size = 2.385&#10;&#10;[node name=&quot;CanvasLayer&quot; type=&quot;CanvasLayer&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;IKControlPanel&quot; type=&quot;Control&quot; parent=&quot;CanvasLayer&quot;]&#10;layout_mode = 3&#10;anchors_preset = 0&#10;script = ExtResource(&quot;5_85g3d&quot;)&#10;metadata/_custom_type_script = &quot;uid://d218u27sl8kf8&quot;&#10;&#10;[node name=&quot;VBoxContainer&quot; type=&quot;VBoxContainer&quot; parent=&quot;CanvasLayer/IKControlPanel&quot;]&#10;layout_mode = 0&#10;offset_right = 500.0&#10;offset_bottom = 153.0&#10;&#10;[node name=&quot;AlgorithmSelector&quot; type=&quot;OptionButton&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;JointCountLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Number of Links:&quot;&#10;&#10;[node name=&quot;JointCountSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;TargetMovementCheckBox&quot; type=&quot;CheckBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Enable Target Movement&quot;&#10;&#10;# New: Target position spinboxes (X, Y, Z)&#10;[node name=&quot;TargetXSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;value = 2.0&#10;step = 0.1&#10;&#10;[node name=&quot;TargetYSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;value = 2.0&#10;step = 0.1&#10;&#10;[node name=&quot;TargetZSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;value = 0.0&#10;step = 0.1&#10;&#10;[node name=&quot;AutoSolveCheckBox&quot; type=&quot;CheckBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Auto Solve&quot;&#10;&#10;[node name=&quot;ToleranceLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;ToleranceSlider&quot; type=&quot;HSlider&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationSlider&quot; type=&quot;HSlider&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;SolveButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Solve IK&quot;&#10;&#10;[node name=&quot;NextStepButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Next Step&quot;&#10;&#10;[node name=&quot;ResetButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Reset&quot;&#10;&#10;[node name=&quot;StepInfoLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;StatsLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationLabel&quot; type=&quot;Label&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;WorldEnvironment&quot; type=&quot;WorldEnvironment&quot; parent=&quot;.&quot;]&#10;environment = SubResource(&quot;Environment_o6xl0&quot;)&#10;" />
              <option name="updatedContent" value="[gd_scene load_steps=10 format=3 uid=&quot;uid://pwcja2iwl6ej&quot;]&#10;&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://cwv0n52mn1n0k&quot; path=&quot;res://scenes/main_scene.gd&quot; id=&quot;1_tbgi4&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://cf0ebjoqwsgky&quot; path=&quot;res://core/ik_controller.gd&quot; id=&quot;2_tefeu&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://blys41lg01fyr&quot; path=&quot;res://visualization/chain_visualizer.gd&quot; id=&quot;3_o6xl0&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://bottxwpbkclic&quot; path=&quot;res://visualization/target_visualizer.gd&quot; id=&quot;4_tipki&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://d218u27sl8kf8&quot; path=&quot;res://ui/ik_control_panel.gd&quot; id=&quot;5_85g3d&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://ivj52hx2vhln&quot; path=&quot;res://core/ik_chain.gd&quot; id=&quot;6_tefeu&quot;]&#10;&#10;[sub_resource type=&quot;ProceduralSkyMaterial&quot; id=&quot;ProceduralSkyMaterial_tefeu&quot;]&#10;sky_top_color = Color(0.546, 0.57199997, 0.65, 1)&#10;sky_horizon_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;ground_bottom_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;ground_horizon_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;&#10;[sub_resource type=&quot;Sky&quot; id=&quot;Sky_tefeu&quot;]&#10;sky_material = SubResource(&quot;ProceduralSkyMaterial_tefeu&quot;)&#10;&#10;[sub_resource type=&quot;Environment&quot; id=&quot;Environment_o6xl0&quot;]&#10;background_mode = 2&#10;sky = SubResource(&quot;Sky_tefeu&quot;)&#10;ambient_light_color = Color(1, 1, 1, 1)&#10;&#10;[node name=&quot;Main&quot; type=&quot;Node3D&quot;]&#10;script = ExtResource(&quot;1_tbgi4&quot;)&#10;&#10;[node name=&quot;IKChain&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;6_tefeu&quot;)&#10;metadata/_custom_type_script = &quot;uid://ivj52hx2vhln&quot;&#10;&#10;[node name=&quot;IKController&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;2_tefeu&quot;)&#10;&#10;[node name=&quot;ChainVisualizer&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;3_o6xl0&quot;)&#10;segment_color = Color(1, 1, 0, 1)&#10;&#10;[node name=&quot;TargetVisualizer&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;4_tipki&quot;)&#10;&#10;[node name=&quot;Camera3D&quot; type=&quot;Camera3D&quot; parent=&quot;.&quot;]&#10;transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0.23479745)&#10;projection = 1&#10;size = 2.385&#10;&#10;[node name=&quot;CanvasLayer&quot; type=&quot;CanvasLayer&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;IKControlPanel&quot; type=&quot;Control&quot; parent=&quot;CanvasLayer&quot;]&#10;layout_mode = 3&#10;anchors_preset = 0&#10;script = ExtResource(&quot;5_85g3d&quot;)&#10;metadata/_custom_type_script = &quot;uid://d218u27sl8kf8&quot;&#10;&#10;[node name=&quot;VBoxContainer&quot; type=&quot;VBoxContainer&quot; parent=&quot;CanvasLayer/IKControlPanel&quot;]&#10;layout_mode = 0&#10;offset_right = 500.0&#10;offset_bottom = 153.0&#10;&#10;[node name=&quot;AlgorithmSelector&quot; type=&quot;OptionButton&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;JointCountLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Number of Links:&quot;&#10;&#10;[node name=&quot;JointCountSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;TargetMovementCheckBox&quot; type=&quot;CheckBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Enable Target Movement&quot;&#10;&#10;# New: Target position spinboxes (X, Y, Z)&#10;[node name=&quot;TargetXSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;value = 2.0&#10;step = 0.1&#10;&#10;[node name=&quot;TargetYSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;value = 2.0&#10;step = 0.1&#10;&#10;[node name=&quot;TargetZSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;value = 0.0&#10;step = 0.1&#10;&#10;[node name=&quot;AutoSolveCheckBox&quot; type=&quot;CheckBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Auto Solve&quot;&#10;&#10;[node name=&quot;ToleranceLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;ToleranceSlider&quot; type=&quot;HSlider&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationSlider&quot; type=&quot;HSlider&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;SolveButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Solve IK&quot;&#10;&#10;[node name=&quot;NextStepButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Next Step&quot;&#10;&#10;[node name=&quot;ResetButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Reset&quot;&#10;&#10;[node name=&quot;StepInfoLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;StatsLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationLabel&quot; type=&quot;Label&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;WorldEnvironment&quot; type=&quot;WorldEnvironment&quot; parent=&quot;.&quot;]&#10;environment = SubResource(&quot;Environment_o6xl0&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scenes/main_scene.gd">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scenes/main_scene.gd" />
              <option name="originalContent" value="## Main scene controller - orchestrates all components&#10;## Follows Dependency Inversion - depends on abstractions (IKController, visualizers)&#10;extends Node3D&#10;&#10;@onready var ik_controller: IKController = $IKController&#10;@onready var chain_visualizer: ChainVisualizer = $ChainVisualizer&#10;@onready var target_visualizer: TargetVisualizer = $TargetVisualizer&#10;@onready var camera: Camera3D = $Camera3D&#10;@onready var control_panel: IKControlPanel = $CanvasLayer/IKControlPanel&#10;&#10;var is_dragging_target: bool = false&#10;var drag_plane: Plane = Plane(Vector3.FORWARD, 0)&#10;var target_movement_enabled: bool = false&#10;var auto_solve_enabled: bool = false&#10;&#10;func _ready() -&gt; void:&#10;&#9;setup_scene()&#10;&#9;connect_signals()&#10;&#10;func setup_scene() -&gt; void:&#10;&#9;if camera:&#10;&#9;&#9;camera.position = Vector3(0, 3, 8)&#10;&#9;&#9;camera.look_at(Vector3.ZERO, Vector3.UP)&#10;&#9;if target_visualizer and ik_controller:&#10;&#9;&#9;var initial_target: Vector3 = Vector3(2, 2, 0)&#10;&#9;&#9;target_visualizer.set_target_position(initial_target)&#10;&#9;&#9;# Also update UI to show initial target&#10;&#9;&#9;if control_panel:&#10;&#9;&#9;&#9;control_panel.set_target_position_in_ui(initial_target)&#10;&#10;func connect_signals() -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.algorithm_changed.connect(_on_algorithm_changed)&#10;&#9;&#9;control_panel.parameters_changed.connect(_on_parameters_changed)&#10;&#9;&#9;control_panel.reset_requested.connect(_on_reset_requested)&#10;&#9;&#9;control_panel.solve_requested.connect(_on_solve_requested)&#10;&#9;&#9;control_panel.next_step_requested.connect(_on_next_step_requested)&#10;&#9;&#9;control_panel.joint_count_changed.connect(_on_joint_count_changed)&#10;&#9;&#9;control_panel.target_movement_toggled.connect(_on_target_movement_toggled)&#10;&#9;&#9;control_panel.auto_solve_toggled.connect(_on_auto_solve_toggled)&#10;&#9;&#9;# Listen to UI changes to move the target&#10;&#9;&#9;control_panel.target_position_changed.connect(_on_ui_target_position_changed)&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.solve_completed.connect(_on_solve_completed)&#10;&#9;&#9;ik_controller.step_executed.connect(_on_step_executed)&#10;&#9;if target_visualizer:&#10;&#9;&#9;# When the visualizer updates its position (e.g. by mouse drag), update the UI&#10;&#9;&#9;target_visualizer.target_moved.connect(_on_target_moved)&#10;&#10;func _input(event: InputEvent) -&gt; void:&#10;&#9;if not target_movement_enabled:&#10;&#9;&#9;return&#10;&#9;if event is InputEventMouseButton:&#10;&#9;&#9;if event.button_index == MOUSE_BUTTON_LEFT:&#10;&#9;&#9;&#9;is_dragging_target = event.pressed&#10;&#9;if event is InputEventMouseMotion and is_dragging_target:&#10;&#9;&#9;move_target_with_mouse(event.position)&#10;&#10;func move_target_with_mouse(screen_pos: Vector2) -&gt; void:&#10;&#9;if not camera or not target_visualizer:&#10;&#9;&#9;return&#10;&#9;var from: Vector3 = camera.project_ray_origin(screen_pos)&#10;&#9;var direction: Vector3 = camera.project_ray_normal(screen_pos)&#10;&#9;var intersection: Variant = drag_plane.intersects_ray(from, direction)&#10;&#9;if intersection:&#10;&#9;&#9;target_visualizer.set_target_position(intersection)&#10;&#10;func _on_algorithm_changed(algorithm_name: String) -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_solver_by_name(algorithm_name)&#10;&#10;func _on_parameters_changed(max_iterations: int, tolerance: float) -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.configure_solver(max_iterations, tolerance)&#10;&#10;func _on_solve_requested() -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_step_mode(false)&#10;&#9;&#9;ik_controller.solve()&#10;&#10;func _on_reset_requested() -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_step_mode(false)&#10;&#9;&#9;ik_controller.reset_chain()&#10;&#10;func _on_solve_completed(_positions: Array[Vector3], iterations: int, final_error: float) -&gt; void:&#10;&#9;if control_panel and ik_controller and ik_controller.solver:&#10;&#9;&#9;control_panel.update_stats(iterations, final_error, ik_controller.solver.get_algorithm_name())&#10;&#10;func _on_next_step_requested() -&gt; void:&#10;&#9;if not ik_controller:&#10;&#9;&#9;return&#10;&#9;if not ik_controller.step_mode_enabled:&#10;&#9;&#9;ik_controller.set_step_mode(true)&#10;&#9;&#9;ik_controller.solve()&#10;&#9;ik_controller.execute_next_step()&#10;&#10;func _on_step_executed(step_info: Dictionary) -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.update_step_info(step_info)&#10;&#10;func _on_joint_count_changed(count: int) -&gt; void:&#10;&#9;if ik_controller and ik_controller.chain:&#10;&#9;&#9;ik_controller.chain.set_joint_count(count)&#10;&#9;&#9;if chain_visualizer:&#10;&#9;&#9;&#9;chain_visualizer.create_visualization()&#10;&#10;func _on_target_movement_toggled(enabled: bool) -&gt; void:&#10;&#9;target_movement_enabled = enabled&#10;&#10;func _on_auto_solve_toggled(enabled: bool) -&gt; void:&#10;&#9;auto_solve_enabled = enabled&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.auto_solve = enabled&#10;&#10;# Called when user edits the TargetPosition fields in the UI&#10;func _on_ui_target_position_changed(target: Vector3) -&gt; void:&#10;&#9;if target_visualizer:&#10;&#9;&#9;target_visualizer.set_target_position(target)&#10;&#10;# Called when the visualizer moves the target (e.g. by mouse drag)&#10;func _on_target_moved(new_pos: Vector3) -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.set_target_position_in_ui(new_pos)" />
              <option name="updatedContent" value="## Main scene controller - orchestrates all components&#10;## Follows Dependency Inversion - depends on abstractions (IKController, visualizers)&#10;extends Node3D&#10;&#10;@onready var ik_controller: IKController = $IKController&#10;@onready var chain_visualizer: ChainVisualizer = $ChainVisualizer&#10;@onready var target_visualizer: TargetVisualizer = $TargetVisualizer&#10;@onready var camera: Camera3D = $Camera3D&#10;@onready var control_panel: IKControlPanel = $CanvasLayer/IKControlPanel&#10;&#10;var is_dragging_target: bool = false&#10;var drag_plane: Plane = Plane(Vector3.FORWARD, 0)&#10;var target_movement_enabled: bool = false&#10;var auto_solve_enabled: bool = false&#10;&#10;func _ready() -&gt; void:&#10;&#9;setup_scene()&#10;&#9;connect_signals()&#10;&#10;func setup_scene() -&gt; void:&#10;&#9;if camera:&#10;&#9;&#9;camera.position = Vector3(0, 3, 8)&#10;&#9;&#9;camera.look_at(Vector3.ZERO, Vector3.UP)&#10;&#9;if target_visualizer and ik_controller:&#10;&#9;&#9;var initial_target: Vector3 = Vector3(2, 2, 0)&#10;&#9;&#9;target_visualizer.set_target_position(initial_target)&#10;&#9;&#9;# Also update UI to show initial target&#10;&#9;&#9;if control_panel:&#10;&#9;&#9;&#9;control_panel.set_target_position_in_ui(initial_target)&#10;&#10;func connect_signals() -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.algorithm_changed.connect(_on_algorithm_changed)&#10;&#9;&#9;control_panel.parameters_changed.connect(_on_parameters_changed)&#10;&#9;&#9;control_panel.reset_requested.connect(_on_reset_requested)&#10;&#9;&#9;control_panel.solve_requested.connect(_on_solve_requested)&#10;&#9;&#9;control_panel.next_step_requested.connect(_on_next_step_requested)&#10;&#9;&#9;control_panel.joint_count_changed.connect(_on_joint_count_changed)&#10;&#9;&#9;control_panel.target_movement_toggled.connect(_on_target_movement_toggled)&#10;&#9;&#9;control_panel.auto_solve_toggled.connect(_on_auto_solve_toggled)&#10;&#9;&#9;# Listen to UI changes to move the target&#10;&#9;&#9;control_panel.target_position_changed.connect(_on_ui_target_position_changed)&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.solve_completed.connect(_on_solve_completed)&#10;&#9;&#9;ik_controller.step_executed.connect(_on_step_executed)&#10;&#9;if target_visualizer:&#10;&#9;&#9;# When the visualizer updates its position (e.g. by mouse drag), update the UI&#10;&#9;&#9;target_visualizer.target_moved.connect(_on_target_moved)&#10;&#10;func _input(event: InputEvent) -&gt; void:&#10;&#9;if not target_movement_enabled:&#10;&#9;&#9;return&#10;&#9;if event is InputEventMouseButton:&#10;&#9;&#9;if event.button_index == MOUSE_BUTTON_LEFT:&#10;&#9;&#9;&#9;is_dragging_target = event.pressed&#10;&#9;if event is InputEventMouseMotion and is_dragging_target:&#10;&#9;&#9;move_target_with_mouse(event.position)&#10;&#10;func move_target_with_mouse(screen_pos: Vector2) -&gt; void:&#10;&#9;if not camera or not target_visualizer:&#10;&#9;&#9;return&#10;&#9;var from: Vector3 = camera.project_ray_origin(screen_pos)&#10;&#9;var direction: Vector3 = camera.project_ray_normal(screen_pos)&#10;&#9;var intersection: Variant = drag_plane.intersects_ray(from, direction)&#10;&#9;if intersection:&#10;&#9;&#9;target_visualizer.set_target_position(intersection)&#10;&#10;func _on_algorithm_changed(algorithm_name: String) -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_solver_by_name(algorithm_name)&#10;&#10;func _on_parameters_changed(max_iterations: int, tolerance: float) -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.configure_solver(max_iterations, tolerance)&#10;&#10;func _on_solve_requested() -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_step_mode(false)&#10;&#9;&#9;ik_controller.solve()&#10;&#10;func _on_reset_requested() -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_step_mode(false)&#10;&#9;&#9;ik_controller.reset_chain()&#10;&#10;func _on_solve_completed(_positions: Array[Vector3], iterations: int, final_error: float) -&gt; void:&#10;&#9;if control_panel and ik_controller and ik_controller.solver:&#10;&#9;&#9;control_panel.update_stats(iterations, final_error, ik_controller.solver.get_algorithm_name())&#10;&#10;func _on_next_step_requested() -&gt; void:&#10;&#9;if not ik_controller:&#10;&#9;&#9;return&#10;&#9;if not ik_controller.step_mode_enabled:&#10;&#9;&#9;ik_controller.set_step_mode(true)&#10;&#9;&#9;ik_controller.solve()&#10;&#9;ik_controller.execute_next_step()&#10;&#10;func _on_step_executed(step_info: Dictionary) -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.update_step_info(step_info)&#10;&#10;func _on_joint_count_changed(count: int) -&gt; void:&#10;&#9;if ik_controller and ik_controller.chain:&#10;&#9;&#9;ik_controller.chain.set_joint_count(count)&#10;&#9;&#9;if chain_visualizer:&#10;&#9;&#9;&#9;chain_visualizer.create_visualization()&#10;&#10;func _on_target_movement_toggled(enabled: bool) -&gt; void:&#10;&#9;target_movement_enabled = enabled&#10;&#10;func _on_auto_solve_toggled(enabled: bool) -&gt; void:&#10;&#9;auto_solve_enabled = enabled&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.auto_solve = enabled&#10;&#10;# Called when user edits the TargetPosition fields in the UI&#10;func _on_ui_target_position_changed(target: Vector3) -&gt; void:&#10;&#9;if target_visualizer:&#10;&#9;&#9;target_visualizer.set_target_position(target)&#10;&#10;# Called when the visualizer moves the target (e.g. by mouse drag)&#10;func _on_target_moved(new_pos: Vector3) -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.set_target_position_in_ui(new_pos)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/ik_control_panel.gd">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/ik_control_panel.gd" />
              <option name="originalContent" value="## UI Control panel for IK visualization (Single Responsibility - UI only)&#10;class_name IKControlPanel extends Control&#10;&#10;signal algorithm_changed(algorithm_name: String)&#10;signal parameters_changed(max_iterations: int, tolerance: float)&#10;signal reset_requested()&#10;signal solve_requested()&#10;signal next_step_requested()&#10;signal joint_count_changed(count: int)&#10;signal target_movement_toggled(enabled: bool)&#10;signal auto_solve_toggled(enabled: bool)&#10;&#10;# New: signal emitted when user changes target position in the UI&#10;signal target_position_changed(target: Vector3)&#10;&#10;@onready var algorithm_selector: OptionButton = $VBoxContainer/AlgorithmSelector&#10;@onready var iteration_slider: HSlider = $VBoxContainer/IterationSlider&#10;@onready var tolerance_slider: HSlider = $VBoxContainer/ToleranceSlider&#10;@onready var iteration_label: Label = $VBoxContainer/IterationLabel&#10;@onready var tolerance_label: Label = $VBoxContainer/ToleranceLabel&#10;@onready var solve_button: Button = $VBoxContainer/SolveButton&#10;@onready var reset_button: Button = $VBoxContainer/ResetButton&#10;@onready var next_step_button: Button = $VBoxContainer/NextStepButton&#10;@onready var step_info_label: Label = $VBoxContainer/StepInfoLabel&#10;@onready var stats_label: Label = $VBoxContainer/StatsLabel&#10;@onready var joint_count_label: Label = $VBoxContainer/JointCountLabel&#10;@onready var joint_count_spinbox: SpinBox = $VBoxContainer/JointCountSpinBox&#10;@onready var target_movement_checkbox: CheckBox = $VBoxContainer/TargetMovementCheckBox&#10;@onready var auto_solve_checkbox: CheckBox = $VBoxContainer/AutoSolveCheckBox&#10;&#10;# New UI elements for target position (X, Y, Z)&#10;@onready var target_x_spinbox: SpinBox = $VBoxContainer/TargetXSpinBox&#10;@onready var target_y_spinbox: SpinBox = $VBoxContainer/TargetYSpinBox&#10;@onready var target_z_spinbox: SpinBox = $VBoxContainer/TargetZSpinBox&#10;&#10;# Internal flag to avoid feedback loops when programmatically updating the UI&#10;var _updating_target_ui: bool = false&#10;&#10;func _ready() -&gt; void:&#10;&#9;setup_ui()&#10;&#9;connect_signals()&#10;&#10;func setup_ui() -&gt; void:&#10;&#9;if algorithm_selector:&#10;&#9;&#9;algorithm_selector.clear()&#10;&#9;&#9;var solvers: Array = IKSolverFactory.get_available_solvers()&#10;&#9;&#9;for solver: String in solvers:&#10;&#9;&#9;&#9;algorithm_selector.add_item(solver)&#10;&#9;if iteration_slider:&#10;&#9;&#9;iteration_slider.min_value = 1&#10;&#9;&#9;iteration_slider.max_value = 100&#10;&#9;&#9;iteration_slider.value = 10&#10;&#9;&#9;update_iteration_label(10)&#10;&#9;if tolerance_slider:&#10;&#9;&#9;tolerance_slider.min_value = 0.001&#10;&#9;&#9;tolerance_slider.max_value = 1.0&#10;&#9;&#9;tolerance_slider.step = 0.001&#10;&#9;&#9;tolerance_slider.value = 0.01&#10;&#9;&#9;update_tolerance_label(0.01)&#10;&#9;if next_step_button:&#10;&#9;&#9;next_step_button.text = &quot;Next Step&quot;&#10;&#9;if step_info_label:&#10;&#9;&#9;step_info_label.text = &quot;&quot;&#10;&#9;if joint_count_label:&#10;&#9;&#9;joint_count_label.text = &quot;Number of Links:&quot;&#10;&#9;if joint_count_spinbox:&#10;&#9;&#9;joint_count_spinbox.min_value = 2&#10;&#9;&#9;joint_count_spinbox.max_value = 20&#10;&#9;&#9;joint_count_spinbox.step = 1&#10;&#9;&#9;joint_count_spinbox.value = 5&#10;&#9;if target_movement_checkbox:&#10;&#9;&#9;target_movement_checkbox.text = &quot;Enable Target Movement&quot;&#10;&#9;&#9;target_movement_checkbox.button_pressed = false&#10;&#9;if auto_solve_checkbox:&#10;&#9;&#9;auto_solve_checkbox.text = &quot;Auto Solve&quot;&#10;&#9;&#9;auto_solve_checkbox.button_pressed = false&#10;&#10;&#9;# Setup target spinboxes&#10;&#9;if target_x_spinbox and target_y_spinbox and target_z_spinbox:&#10;&#9;&#9;target_x_spinbox.step = 0.1&#10;&#9;&#9;target_x_spinbox.min_value = -1000.0&#10;&#9;&#9;target_x_spinbox.max_value = 1000.0&#10;&#9;&#9;target_x_spinbox.value = 2.0&#10;&#9;&#9;target_y_spinbox.step = 0.1&#10;&#9;&#9;target_y_spinbox.min_value = -1000.0&#10;&#9;&#9;target_y_spinbox.max_value = 1000.0&#10;&#9;&#9;target_y_spinbox.value = 2.0&#10;&#9;&#9;target_z_spinbox.step = 0.1&#10;&#9;&#9;target_z_spinbox.min_value = -1000.0&#10;&#9;&#9;target_z_spinbox.max_value = 1000.0&#10;&#9;&#9;target_z_spinbox.value = 0.0&#10;&#10;func connect_signals() -&gt; void:&#10;&#9;if algorithm_selector:&#10;&#9;&#9;algorithm_selector.item_selected.connect(_on_algorithm_selected)&#10;&#9;if iteration_slider:&#10;&#9;&#9;iteration_slider.value_changed.connect(_on_iteration_changed)&#10;&#9;if tolerance_slider:&#10;&#9;&#9;tolerance_slider.value_changed.connect(_on_tolerance_changed)&#10;&#9;if solve_button:&#10;&#9;&#9;solve_button.pressed.connect(_on_solve_pressed)&#10;&#9;if next_step_button:&#10;&#9;&#9;next_step_button.pressed.connect(_on_next_step_pressed)&#10;&#9;if reset_button:&#10;&#9;&#9;reset_button.pressed.connect(_on_reset_pressed)&#10;&#9;if joint_count_spinbox:&#10;&#9;&#9;joint_count_spinbox.value_changed.connect(_on_joint_count_changed)&#10;&#9;if target_movement_checkbox:&#10;&#9;&#9;target_movement_checkbox.toggled.connect(_on_target_movement_toggled)&#10;&#9;if auto_solve_checkbox:&#10;&#9;&#9;auto_solve_checkbox.toggled.connect(_on_auto_solve_toggled)&#10;&#10;&#9;# Connect target spinboxes (user changes -&gt; emit target_position_changed)&#10;&#9;if target_x_spinbox:&#10;&#9;&#9;target_x_spinbox.value_changed.connect(_on_target_spin_changed)&#10;&#9;if target_y_spinbox:&#10;&#9;&#9;target_y_spinbox.value_changed.connect(_on_target_spin_changed)&#10;&#9;if target_z_spinbox:&#10;&#9;&#9;target_z_spinbox.value_changed.connect(_on_target_spin_changed)&#10;&#10;func _on_algorithm_selected(index: int) -&gt; void:&#10;&#9;var algorithm_name: String = algorithm_selector.get_item_text(index)&#10;&#9;algorithm_changed.emit(algorithm_name)&#10;&#10;func _on_iteration_changed(value: float) -&gt; void:&#10;&#9;update_iteration_label(int(value))&#10;&#9;emit_parameters()&#10;&#10;func _on_tolerance_changed(value: float) -&gt; void:&#10;&#9;update_tolerance_label(value)&#10;&#9;emit_parameters()&#10;&#10;func _on_solve_pressed() -&gt; void:&#10;&#9;solve_requested.emit()&#10;&#10;func _on_reset_pressed() -&gt; void:&#10;&#9;reset_requested.emit()&#10;&#9;if step_info_label:&#10;&#9;&#9;step_info_label.text = &quot;&quot;&#10;&#10;func _on_next_step_pressed() -&gt; void:&#10;&#9;next_step_requested.emit()&#10;&#10;func emit_parameters() -&gt; void:&#10;&#9;if iteration_slider and tolerance_slider:&#10;&#9;&#9;parameters_changed.emit(int(iteration_slider.value), tolerance_slider.value)&#10;&#10;func update_iteration_label(value: int) -&gt; void:&#10;&#9;if iteration_label:&#10;&#9;&#9;iteration_label.text = &quot;Max Iterations: &quot; + str(value)&#10;&#10;func update_tolerance_label(value: float) -&gt; void:&#10;&#9;if tolerance_label:&#10;&#9;&#9;tolerance_label.text = &quot;Tolerance: &quot; + str(value)&#10;&#10;func update_stats(iterations: int, error: float, algorithm: String) -&gt; void:&#10;&#9;if stats_label:&#10;&#9;&#9;stats_label.text = &quot;Algorithm: %s\nIterations: %d\nError: %.4f&quot; % [algorithm, iterations, error]&#10;&#10;func update_step_info(step_info: Dictionary) -&gt; void:&#10;&#9;if step_info_label and step_info.has(&quot;description&quot;):&#10;&#9;&#9;var text: String = &quot;Step %d/%d\n%s\nError: %.4f&quot; % [&#10;&#9;&#9;&#9;step_info.get(&quot;current_step&quot;, 0),&#10;&#9;&#9;&#9;step_info.get(&quot;total_steps&quot;, 0),&#10;&#9;&#9;&#9;step_info.get(&quot;description&quot;, &quot;&quot;),&#10;&#9;&#9;&#9;step_info.get(&quot;error&quot;, 0.0)&#10;&#9;&#9;]&#10;&#9;&#9;step_info_label.text = text&#10;&#10;func _on_joint_count_changed(value: float) -&gt; void:&#10;&#9;joint_count_changed.emit(int(value))&#10;&#10;func _on_target_movement_toggled(pressed: bool) -&gt; void:&#10;&#9;target_movement_toggled.emit(pressed)&#10;&#10;func _on_auto_solve_toggled(pressed: bool) -&gt; void:&#10;&#9;auto_solve_toggled.emit(pressed)&#10;&#10;# Called when any of the three spinboxes change value due to user interaction&#10;func _on_target_spin_changed(value: float) -&gt; void:&#10;&#9;# Ignore updates triggered by programmatic UI changes&#10;&#9;if _updating_target_ui:&#10;&#9;&#9;return&#10;&#9;if not target_x_spinbox or not target_y_spinbox or not target_z_spinbox:&#10;&#9;&#9;return&#10;&#9;var pos: Vector3 = Vector3(target_x_spinbox.value, target_y_spinbox.value, target_z_spinbox.value)&#10;&#9;target_position_changed.emit(pos)&#10;&#10;# Programmatically set the values displayed in the UI without emitting a change signal&#10;func set_target_position_in_ui(pos: Vector3) -&gt; void:&#10;&#9;if not target_x_spinbox or not target_y_spinbox or not target_z_spinbox:&#10;&#9;&#9;return&#10;&#9;_updating_target_ui = true&#10;&#9;target_x_spinbox.value = pos.x&#10;&#9;target_y_spinbox.value = pos.y&#10;&#9;target_z_spinbox.value = pos.z&#10;&#9;_updating_target_ui = false&#10;" />
              <option name="updatedContent" value="## UI Control panel for IK visualization (Single Responsibility - UI only)&#10;class_name IKControlPanel extends Control&#10;&#10;signal algorithm_changed(algorithm_name: String)&#10;signal parameters_changed(max_iterations: int, tolerance: float)&#10;signal reset_requested()&#10;signal solve_requested()&#10;signal next_step_requested()&#10;signal joint_count_changed(count: int)&#10;signal target_movement_toggled(enabled: bool)&#10;signal auto_solve_toggled(enabled: bool)&#10;&#10;# New: signal emitted when user changes target position in the UI&#10;signal target_position_changed(target: Vector3)&#10;&#10;@onready var algorithm_selector: OptionButton = $VBoxContainer/AlgorithmSelector&#10;@onready var iteration_slider: HSlider = $VBoxContainer/IterationSlider&#10;@onready var tolerance_slider: HSlider = $VBoxContainer/ToleranceSlider&#10;@onready var iteration_label: Label = $VBoxContainer/IterationLabel&#10;@onready var tolerance_label: Label = $VBoxContainer/ToleranceLabel&#10;@onready var solve_button: Button = $VBoxContainer/SolveButton&#10;@onready var reset_button: Button = $VBoxContainer/ResetButton&#10;@onready var next_step_button: Button = $VBoxContainer/NextStepButton&#10;@onready var step_info_label: Label = $VBoxContainer/StepInfoLabel&#10;@onready var stats_label: Label = $VBoxContainer/StatsLabel&#10;@onready var joint_count_label: Label = $VBoxContainer/JointCountLabel&#10;@onready var joint_count_spinbox: SpinBox = $VBoxContainer/JointCountSpinBox&#10;@onready var target_movement_checkbox: CheckBox = $VBoxContainer/TargetMovementCheckBox&#10;@onready var auto_solve_checkbox: CheckBox = $VBoxContainer/AutoSolveCheckBox&#10;&#10;# New UI elements for target position (X, Y, Z)&#10;@onready var target_x_spinbox: SpinBox = $VBoxContainer/TargetXSpinBox&#10;@onready var target_y_spinbox: SpinBox = $VBoxContainer/TargetYSpinBox&#10;@onready var target_z_spinbox: SpinBox = $VBoxContainer/TargetZSpinBox&#10;&#10;# Internal flag to avoid feedback loops when programmatically updating the UI&#10;var _updating_target_ui: bool = false&#10;&#10;func _ready() -&gt; void:&#10;&#9;setup_ui()&#10;&#9;connect_signals()&#10;&#10;func setup_ui() -&gt; void:&#10;&#9;if algorithm_selector:&#10;&#9;&#9;algorithm_selector.clear()&#10;&#9;&#9;var solvers: Array = IKSolverFactory.get_available_solvers()&#10;&#9;&#9;for solver: String in solvers:&#10;&#9;&#9;&#9;algorithm_selector.add_item(solver)&#10;&#9;if iteration_slider:&#10;&#9;&#9;iteration_slider.min_value = 1&#10;&#9;&#9;iteration_slider.max_value = 100&#10;&#9;&#9;iteration_slider.value = 10&#10;&#9;&#9;update_iteration_label(10)&#10;&#9;if tolerance_slider:&#10;&#9;&#9;tolerance_slider.min_value = 0.001&#10;&#9;&#9;tolerance_slider.max_value = 1.0&#10;&#9;&#9;tolerance_slider.step = 0.001&#10;&#9;&#9;tolerance_slider.value = 0.01&#10;&#9;&#9;update_tolerance_label(0.01)&#10;&#9;if next_step_button:&#10;&#9;&#9;next_step_button.text = &quot;Next Step&quot;&#10;&#9;if step_info_label:&#10;&#9;&#9;step_info_label.text = &quot;&quot;&#10;&#9;if joint_count_label:&#10;&#9;&#9;joint_count_label.text = &quot;Number of Links:&quot;&#10;&#9;if joint_count_spinbox:&#10;&#9;&#9;joint_count_spinbox.min_value = 2&#10;&#9;&#9;joint_count_spinbox.max_value = 20&#10;&#9;&#9;joint_count_spinbox.step = 1&#10;&#9;&#9;joint_count_spinbox.value = 5&#10;&#9;if target_movement_checkbox:&#10;&#9;&#9;target_movement_checkbox.text = &quot;Enable Target Movement&quot;&#10;&#9;&#9;target_movement_checkbox.button_pressed = false&#10;&#9;if auto_solve_checkbox:&#10;&#9;&#9;auto_solve_checkbox.text = &quot;Auto Solve&quot;&#10;&#9;&#9;auto_solve_checkbox.button_pressed = false&#10;&#10;&#9;# Setup target spinboxes&#10;&#9;if target_x_spinbox and target_y_spinbox and target_z_spinbox:&#10;&#9;&#9;target_x_spinbox.step = 0.1&#10;&#9;&#9;target_x_spinbox.min_value = -1000.0&#10;&#9;&#9;target_x_spinbox.max_value = 1000.0&#10;&#9;&#9;target_x_spinbox.value = 2.0&#10;&#9;&#9;target_y_spinbox.step = 0.1&#10;&#9;&#9;target_y_spinbox.min_value = -1000.0&#10;&#9;&#9;target_y_spinbox.max_value = 1000.0&#10;&#9;&#9;target_y_spinbox.value = 2.0&#10;&#9;&#9;target_z_spinbox.step = 0.1&#10;&#9;&#9;target_z_spinbox.min_value = -1000.0&#10;&#9;&#9;target_z_spinbox.max_value = 1000.0&#10;&#9;&#9;target_z_spinbox.value = 0.0&#10;&#10;func connect_signals() -&gt; void:&#10;&#9;if algorithm_selector:&#10;&#9;&#9;algorithm_selector.item_selected.connect(_on_algorithm_selected)&#10;&#9;if iteration_slider:&#10;&#9;&#9;iteration_slider.value_changed.connect(_on_iteration_changed)&#10;&#9;if tolerance_slider:&#10;&#9;&#9;tolerance_slider.value_changed.connect(_on_tolerance_changed)&#10;&#9;if solve_button:&#10;&#9;&#9;solve_button.pressed.connect(_on_solve_pressed)&#10;&#9;if next_step_button:&#10;&#9;&#9;next_step_button.pressed.connect(_on_next_step_pressed)&#10;&#9;if reset_button:&#10;&#9;&#9;reset_button.pressed.connect(_on_reset_pressed)&#10;&#9;if joint_count_spinbox:&#10;&#9;&#9;joint_count_spinbox.value_changed.connect(_on_joint_count_changed)&#10;&#9;if target_movement_checkbox:&#10;&#9;&#9;target_movement_checkbox.toggled.connect(_on_target_movement_toggled)&#10;&#9;if auto_solve_checkbox:&#10;&#9;&#9;auto_solve_checkbox.toggled.connect(_on_auto_solve_toggled)&#10;&#10;&#9;# Connect target spinboxes (user changes -&gt; emit target_position_changed)&#10;&#9;if target_x_spinbox:&#10;&#9;&#9;target_x_spinbox.value_changed.connect(_on_target_spin_changed)&#10;&#9;if target_y_spinbox:&#10;&#9;&#9;target_y_spinbox.value_changed.connect(_on_target_spin_changed)&#10;&#9;if target_z_spinbox:&#10;&#9;&#9;target_z_spinbox.value_changed.connect(_on_target_spin_changed)&#10;&#10;func _on_algorithm_selected(index: int) -&gt; void:&#10;&#9;var algorithm_name: String = algorithm_selector.get_item_text(index)&#10;&#9;algorithm_changed.emit(algorithm_name)&#10;&#10;func _on_iteration_changed(value: float) -&gt; void:&#10;&#9;update_iteration_label(int(value))&#10;&#9;emit_parameters()&#10;&#10;func _on_tolerance_changed(value: float) -&gt; void:&#10;&#9;update_tolerance_label(value)&#10;&#9;emit_parameters()&#10;&#10;func _on_solve_pressed() -&gt; void:&#10;&#9;solve_requested.emit()&#10;&#10;func _on_reset_pressed() -&gt; void:&#10;&#9;reset_requested.emit()&#10;&#9;if step_info_label:&#10;&#9;&#9;step_info_label.text = &quot;&quot;&#10;&#10;func _on_next_step_pressed() -&gt; void:&#10;&#9;next_step_requested.emit()&#10;&#10;func emit_parameters() -&gt; void:&#10;&#9;if iteration_slider and tolerance_slider:&#10;&#9;&#9;parameters_changed.emit(int(iteration_slider.value), tolerance_slider.value)&#10;&#10;func update_iteration_label(value: int) -&gt; void:&#10;&#9;if iteration_label:&#10;&#9;&#9;iteration_label.text = &quot;Max Iterations: &quot; + str(value)&#10;&#10;func update_tolerance_label(value: float) -&gt; void:&#10;&#9;if tolerance_label:&#10;&#9;&#9;tolerance_label.text = &quot;Tolerance: &quot; + str(value)&#10;&#10;func update_stats(iterations: int, error: float, algorithm: String) -&gt; void:&#10;&#9;if stats_label:&#10;&#9;&#9;stats_label.text = &quot;Algorithm: %s\nIterations: %d\nError: %.4f&quot; % [algorithm, iterations, error]&#10;&#10;func update_step_info(step_info: Dictionary) -&gt; void:&#10;&#9;if step_info_label and step_info.has(&quot;description&quot;):&#10;&#9;&#9;var text: String = &quot;Step %d/%d\n%s\nError: %.4f&quot; % [&#10;&#9;&#9;&#9;step_info.get(&quot;current_step&quot;, 0),&#10;&#9;&#9;&#9;step_info.get(&quot;total_steps&quot;, 0),&#10;&#9;&#9;&#9;step_info.get(&quot;description&quot;, &quot;&quot;),&#10;&#9;&#9;&#9;step_info.get(&quot;error&quot;, 0.0)&#10;&#9;&#9;]&#10;&#9;&#9;step_info_label.text = text&#10;&#10;func _on_joint_count_changed(value: float) -&gt; void:&#10;&#9;joint_count_changed.emit(int(value))&#10;&#10;func _on_target_movement_toggled(pressed: bool) -&gt; void:&#10;&#9;target_movement_toggled.emit(pressed)&#10;&#10;func _on_auto_solve_toggled(pressed: bool) -&gt; void:&#10;&#9;auto_solve_toggled.emit(pressed)&#10;&#10;# Called when any of the three spinboxes change value due to user interaction&#10;func _on_target_spin_changed(value: float) -&gt; void:&#10;&#9;# Ignore updates triggered by programmatic UI changes&#10;&#9;if _updating_target_ui:&#10;&#9;&#9;return&#10;&#9;if not target_x_spinbox or not target_y_spinbox or not target_z_spinbox:&#10;&#9;&#9;return&#10;&#9;var pos: Vector3 = Vector3(target_x_spinbox.value, target_y_spinbox.value, target_z_spinbox.value)&#10;&#9;target_position_changed.emit(pos)&#10;&#10;# Programmatically set the values displayed in the UI without emitting a change signal&#10;func set_target_position_in_ui(pos: Vector3) -&gt; void:&#10;&#9;if not target_x_spinbox or not target_y_spinbox or not target_z_spinbox:&#10;&#9;&#9;return&#10;&#9;_updating_target_ui = true&#10;&#9;target_x_spinbox.value = pos.x&#10;&#9;target_y_spinbox.value = pos.y&#10;&#9;target_z_spinbox.value = pos.z&#10;&#9;_updating_target_ui = false&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>