<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ik_chain.gd">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ik_chain.gd" />
              <option name="originalContent" value="## Represents a kinematic chain of joints (Single Responsibility)&#10;## Manages the chain data structure and basic operations&#10;class_name IKChain extends Node3D&#10;&#10;## Emitted when the chain is updated&#10;signal chain_updated(positions: Array[Vector3])&#10;&#10;## Joint nodes in the chain&#10;@export var joint_count: int = 5&#10;@export var segment_length: float = 1.0&#10;@export var initial_orientation: Vector3 = Vector3.DOWN&#10;&#10;var joints: Array[Node3D] = []&#10;var joint_positions: Array[Vector3] = []&#10;&#10;func _ready() -&gt; void:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;create_default_chain()&#10;&#9;# Emit chain_updated so camera or other listeners can fit to initial positions&#10;&#9;chain_updated.emit(get_positions())&#10;&#10;## Creates a default chain if none exists&#10;func create_default_chain() -&gt; void:&#10;&#9;var direction: Vector3 = initial_orientation.normalized()&#10;&#9;var current_pos: Vector3 = Vector3.ZERO&#10;&#9;for i in range(joint_count):&#10;&#9;&#9;var joint: Node3D = Node3D.new()&#10;&#9;&#9;joint.name = &quot;Joint_&quot; + str(i)&#10;&#9;&#9;joint.position = current_pos&#10;&#9;&#9;add_child(joint)&#10;&#9;&#9;joints.append(joint)&#10;&#9;&#9;joint_positions.append(current_pos)&#10;&#9;&#9;current_pos += direction * segment_length&#10;&#10;## Gets current positions of all joints&#10;func get_positions() -&gt; Array[Vector3]:&#10;&#9;joint_positions.clear()&#10;&#9;for joint in joints:&#10;&#9;&#9;joint_positions.append(joint.global_position)&#10;&#9;return joint_positions&#10;&#10;## Updates joint positions&#10;func update_positions(new_positions: Array[Vector3]) -&gt; void:&#10;&#9;if new_positions.size() != joints.size():&#10;&#9;&#9;push_error(&quot;Position array size mismatch&quot;)&#10;&#9;&#9;return&#10;&#9;for i in range(joints.size()):&#10;&#9;&#9;joints[i].global_position = new_positions[i]&#10;&#9;joint_positions = new_positions.duplicate()&#10;&#9;chain_updated.emit(joint_positions)&#10;&#10;## Gets the root position&#10;func get_root_position() -&gt; Vector3:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return Vector3.ZERO&#10;&#9;return joints[0].global_position&#10;&#10;## Gets the end effector position&#10;func get_end_effector_position() -&gt; Vector3:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return Vector3.ZERO&#10;&#9;return joints[joints.size() - 1].global_position&#10;&#10;## Resets chain to initial configuration&#10;func reset() -&gt; void:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return&#10;&#9;var direction: Vector3 = initial_orientation.normalized()&#10;&#9;var current_pos: Vector3 = get_root_position()&#10;&#9;for i in range(joints.size()):&#10;&#9;&#9;joints[i].global_position = current_pos&#10;&#9;&#9;current_pos += direction * segment_length&#10;&#9;chain_updated.emit(get_positions())&#10;&#10;## Recreates the chain with a new joint count&#10;func set_joint_count(new_count: int) -&gt; void:&#10;&#9;if new_count &lt; 2:&#10;&#9;&#9;push_error(&quot;Joint count must be at least 2&quot;)&#10;&#9;&#9;return&#10;&#9;for joint in joints:&#10;&#9;&#9;joint.queue_free()&#10;&#9;joints.clear()&#10;&#9;joint_positions.clear()&#10;&#9;joint_count = new_count&#10;&#9;create_default_chain()&#10;&#9;chain_updated.emit(get_positions())&#10;&#10;&#10;" />
              <option name="updatedContent" value="## Represents a kinematic chain of joints (Single Responsibility)&#10;## Manages the chain data structure and basic operations&#10;class_name IKChain extends Node3D&#10;&#10;## Emitted when the chain is updated&#10;signal chain_updated(positions: Array[Vector3])&#10;&#10;## Joint nodes in the chain&#10;@export var joint_count: int = 5&#10;@export var segment_length: float = 1.0&#10;@export var initial_orientation: Vector3 = Vector3.DOWN&#10;&#10;var joints: Array[Node3D] = []&#10;var joint_positions: Array[Vector3] = []&#10;&#10;func _ready() -&gt; void:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;create_default_chain()&#10;&#9;# Emit chain_updated so camera or other listeners can fit to initial positions&#10;&#9;chain_updated.emit(get_positions())&#10;&#10;## Creates a default chain if none exists&#10;func create_default_chain() -&gt; void:&#10;&#9;var direction: Vector3 = initial_orientation.normalized()&#10;&#9;var current_pos: Vector3 = Vector3.ZERO&#10;&#9;for i in range(joint_count):&#10;&#9;&#9;var joint: Node3D = Node3D.new()&#10;&#9;&#9;joint.name = &quot;Joint_&quot; + str(i)&#10;&#9;&#9;joint.position = current_pos&#10;&#9;&#9;add_child(joint)&#10;&#9;&#9;joints.append(joint)&#10;&#9;&#9;joint_positions.append(current_pos)&#10;&#9;&#9;current_pos += direction * segment_length&#10;&#10;## Gets current positions of all joints&#10;func get_positions() -&gt; Array[Vector3]:&#10;&#9;joint_positions.clear()&#10;&#9;for joint in joints:&#10;&#9;&#9;joint_positions.append(joint.global_position)&#10;&#9;return joint_positions&#10;&#10;## Updates joint positions&#10;func update_positions(new_positions: Array[Vector3]) -&gt; void:&#10;&#9;if new_positions.size() != joints.size():&#10;&#9;&#9;push_error(&quot;Position array size mismatch&quot;)&#10;&#9;&#9;return&#10;&#9;for i in range(joints.size()):&#10;&#9;&#9;joints[i].global_position = new_positions[i]&#10;&#9;joint_positions = new_positions.duplicate()&#10;&#9;chain_updated.emit(joint_positions)&#10;&#10;## Gets the root position&#10;func get_root_position() -&gt; Vector3:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return Vector3.ZERO&#10;&#9;return joints[0].global_position&#10;&#10;## Gets the end effector position&#10;func get_end_effector_position() -&gt; Vector3:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return Vector3.ZERO&#10;&#9;return joints[joints.size() - 1].global_position&#10;&#10;## Resets chain to initial configuration&#10;func reset() -&gt; void:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return&#10;&#9;var direction: Vector3 = initial_orientation.normalized()&#10;&#9;var current_pos: Vector3 = get_root_position()&#10;&#9;for i in range(joints.size()):&#10;&#9;&#9;joints[i].global_position = current_pos&#10;&#9;&#9;current_pos += direction * segment_length&#10;&#9;chain_updated.emit(get_positions())&#10;&#10;## Recreates the chain with a new joint count&#10;func set_joint_count(new_count: int) -&gt; void:&#10;&#9;if new_count &lt; 2:&#10;&#9;&#9;push_error(&quot;Joint count must be at least 2&quot;)&#10;&#9;&#9;return&#10;&#9;for joint in joints:&#10;&#9;&#9;joint.queue_free()&#10;&#9;joints.clear()&#10;&#9;joint_positions.clear()&#10;&#9;joint_count = new_count&#10;&#9;create_default_chain()&#10;&#9;chain_updated.emit(get_positions())" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>