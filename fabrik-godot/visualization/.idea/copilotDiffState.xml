<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/../core/ik_chain.gd">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../core/ik_chain.gd" />
              <option name="originalContent" value="## Represents a kinematic chain of joints (Single Responsibility)&#10;## Manages the chain data structure and basic operations&#10;class_name IKChain extends Node3D&#10;&#10;## Emitted when the chain is updated&#10;signal chain_updated(positions: Array[Vector3])&#10;&#10;## Joint nodes in the chain&#10;@export var joint_count: int = 5&#10;@export var segment_length: float = 1.0&#10;@export var initial_orientation: Vector3 = Vector3.DOWN&#10;&#10;var joints: Array[Node3D] = []&#10;var joint_positions: Array[Vector3] = []&#10;&#10;func _ready() -&gt; void:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;create_default_chain()&#10;&#10;## Creates a default chain if none exists&#10;func create_default_chain() -&gt; void:&#10;&#9;var direction: Vector3 = initial_orientation.normalized()&#10;&#9;var current_pos: Vector3 = Vector3.ZERO&#10;&#9;for i in range(joint_count):&#10;&#9;&#9;var joint: Node3D = Node3D.new()&#10;&#9;&#9;joint.name = &quot;Joint_&quot; + str(i)&#10;&#9;&#9;joint.position = current_pos&#10;&#9;&#9;add_child(joint)&#10;&#9;&#9;joints.append(joint)&#10;&#9;&#9;joint_positions.append(current_pos)&#10;&#9;&#9;current_pos += direction * segment_length&#10;&#10;## Gets current positions of all joints&#10;func get_positions() -&gt; Array[Vector3]:&#10;&#9;joint_positions.clear()&#10;&#9;for joint in joints:&#10;&#9;&#9;joint_positions.append(joint.global_position)&#10;&#9;return joint_positions&#10;&#10;## Updates joint positions&#10;func update_positions(new_positions: Array[Vector3]) -&gt; void:&#10;&#9;if new_positions.size() != joints.size():&#10;&#9;&#9;push_error(&quot;Position array size mismatch&quot;)&#10;&#9;&#9;return&#10;&#9;for i in range(joints.size()):&#10;&#9;&#9;joints[i].global_position = new_positions[i]&#10;&#9;joint_positions = new_positions.duplicate()&#10;&#9;chain_updated.emit(joint_positions)&#10;&#10;## Gets the root position&#10;func get_root_position() -&gt; Vector3:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return Vector3.ZERO&#10;&#9;return joints[0].global_position&#10;&#10;## Gets the end effector position&#10;func get_end_effector_position() -&gt; Vector3:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return Vector3.ZERO&#10;&#9;return joints[joints.size() - 1].global_position&#10;&#10;## Resets chain to initial configuration&#10;func reset() -&gt; void:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return&#10;&#9;var direction: Vector3 = initial_orientation.normalized()&#10;&#9;var current_pos: Vector3 = get_root_position()&#10;&#9;for i in range(joints.size()):&#10;&#9;&#9;joints[i].global_position = current_pos&#10;&#9;&#9;current_pos += direction * segment_length&#10;&#9;chain_updated.emit(get_positions())&#10;&#10;## Recreates the chain with a new joint count&#10;func set_joint_count(new_count: int) -&gt; void:&#10;&#9;if new_count &lt; 2:&#10;&#9;&#9;push_error(&quot;Joint count must be at least 2&quot;)&#10;&#9;&#9;return&#10;&#9;# Clear existing joints&#10;&#9;for joint in joints:&#10;&#9;&#9;joint.queue_free()&#10;&#9;joints.clear()&#10;&#9;joint_positions.clear()&#10;&#9;&#10;&#9;# Update the joint count&#10;&#9;joint_count = new_count&#10;&#9;&#10;&#9;# Create new chain&#10;&#9;create_default_chain()&#10;&#9;chain_updated.emit(get_positions())&#10;&#10;&#10;" />
              <option name="updatedContent" value="## Represents a kinematic chain of joints (Single Responsibility)&#10;## Manages the chain data structure and basic operations&#10;class_name IKChain extends Node3D&#10;&#10;## Emitted when the chain is updated&#10;signal chain_updated(positions: Array[Vector3])&#10;&#10;## Joint nodes in the chain&#10;@export var joint_count: int = 5&#10;@export var segment_length: float = 1.0&#10;@export var initial_orientation: Vector3 = Vector3.DOWN&#10;&#10;var joints: Array[Node3D] = []&#10;var joint_positions: Array[Vector3] = []&#10;&#10;func _ready() -&gt; void:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;create_default_chain()&#10;&#10;## Creates a default chain if none exists&#10;func create_default_chain() -&gt; void:&#10;&#9;var direction: Vector3 = initial_orientation.normalized()&#10;&#9;var current_pos: Vector3 = Vector3.ZERO&#10;&#9;for i in range(joint_count):&#10;&#9;&#9;var joint: Node3D = Node3D.new()&#10;&#9;&#9;joint.name = &quot;Joint_&quot; + str(i)&#10;&#9;&#9;joint.position = current_pos&#10;&#9;&#9;add_child(joint)&#10;&#9;&#9;joints.append(joint)&#10;&#9;&#9;joint_positions.append(current_pos)&#10;&#9;&#9;current_pos += direction * segment_length&#10;&#10;## Gets current positions of all joints&#10;func get_positions() -&gt; Array[Vector3]:&#10;&#9;joint_positions.clear()&#10;&#9;for joint in joints:&#10;&#9;&#9;joint_positions.append(joint.global_position)&#10;&#9;return joint_positions&#10;&#10;## Updates joint positions&#10;func update_positions(new_positions: Array[Vector3]) -&gt; void:&#10;&#9;if new_positions.size() != joints.size():&#10;&#9;&#9;push_error(&quot;Position array size mismatch&quot;)&#10;&#9;&#9;return&#10;&#9;for i in range(joints.size()):&#10;&#9;&#9;joints[i].global_position = new_positions[i]&#10;&#9;joint_positions = new_positions.duplicate()&#10;&#9;chain_updated.emit(joint_positions)&#10;&#10;## Gets the root position&#10;func get_root_position() -&gt; Vector3:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return Vector3.ZERO&#10;&#9;return joints[0].global_position&#10;&#10;## Gets the end effector position&#10;func get_end_effector_position() -&gt; Vector3:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return Vector3.ZERO&#10;&#9;return joints[joints.size() - 1].global_position&#10;&#10;## Resets chain to initial configuration&#10;func reset() -&gt; void:&#10;&#9;if joints.is_empty():&#10;&#9;&#9;return&#10;&#9;var direction: Vector3 = initial_orientation.normalized()&#10;&#9;var current_pos: Vector3 = get_root_position()&#10;&#9;for i in range(joints.size()):&#10;&#9;&#9;joints[i].global_position = current_pos&#10;&#9;&#9;current_pos += direction * segment_length&#10;&#9;chain_updated.emit(get_positions())&#10;&#10;## Recreates the chain with a new joint count&#10;func set_joint_count(new_count: int) -&gt; void:&#10;&#9;if new_count &lt; 2:&#10;&#9;&#9;push_error(&quot;Joint count must be at least 2&quot;)&#10;&#9;&#9;return&#10;&#9;# Clear existing joints&#10;&#9;for joint in joints:&#10;&#9;&#9;joint.queue_free()&#10;&#9;joints.clear()&#10;&#9;joint_positions.clear()&#10;&#9;&#10;&#9;# Update the joint count&#10;&#9;joint_count = new_count&#10;&#9;&#10;&#9;# Create new chain&#10;&#9;create_default_chain()&#10;&#9;chain_updated.emit(get_positions())&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/../scenes/main.tscn">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../scenes/main.tscn" />
              <option name="originalContent" value="[gd_scene load_steps=10 format=3 uid=&quot;uid://pwcja2iwl6ej&quot;]&#10;&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://cwv0n52mn1n0k&quot; path=&quot;res://scenes/main_scene.gd&quot; id=&quot;1_tbgi4&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://cf0ebjoqwsgky&quot; path=&quot;res://core/ik_controller.gd&quot; id=&quot;2_tefeu&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://blys41lg01fyr&quot; path=&quot;res://visualization/chain_visualizer.gd&quot; id=&quot;3_o6xl0&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://bottxwpbkclic&quot; path=&quot;res://visualization/target_visualizer.gd&quot; id=&quot;4_tipki&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://d218u27sl8kf8&quot; path=&quot;res://ui/ik_control_panel.gd&quot; id=&quot;5_85g3d&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://ivj52hx2vhln&quot; path=&quot;res://core/ik_chain.gd&quot; id=&quot;6_tefeu&quot;]&#10;&#10;[sub_resource type=&quot;ProceduralSkyMaterial&quot; id=&quot;ProceduralSkyMaterial_tefeu&quot;]&#10;sky_top_color = Color(0.546, 0.57199997, 0.65, 1)&#10;sky_horizon_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;ground_bottom_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;ground_horizon_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;&#10;[sub_resource type=&quot;Sky&quot; id=&quot;Sky_tefeu&quot;]&#10;sky_material = SubResource(&quot;ProceduralSkyMaterial_tefeu&quot;)&#10;&#10;[sub_resource type=&quot;Environment&quot; id=&quot;Environment_o6xl0&quot;]&#10;background_mode = 2&#10;sky = SubResource(&quot;Sky_tefeu&quot;)&#10;ambient_light_color = Color(1, 1, 1, 1)&#10;&#10;[node name=&quot;Main&quot; type=&quot;Node3D&quot;]&#10;script = ExtResource(&quot;1_tbgi4&quot;)&#10;&#10;[node name=&quot;IKChain&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;6_tefeu&quot;)&#10;metadata/_custom_type_script = &quot;uid://ivj52hx2vhln&quot;&#10;&#10;[node name=&quot;IKController&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;2_tefeu&quot;)&#10;&#10;[node name=&quot;ChainVisualizer&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;3_o6xl0&quot;)&#10;segment_color = Color(1, 1, 0, 1)&#10;&#10;[node name=&quot;TargetVisualizer&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;4_tipki&quot;)&#10;&#10;[node name=&quot;Camera3D&quot; type=&quot;Camera3D&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;CanvasLayer&quot; type=&quot;CanvasLayer&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;IKControlPanel&quot; type=&quot;Control&quot; parent=&quot;CanvasLayer&quot;]&#10;layout_mode = 3&#10;anchors_preset = 0&#10;script = ExtResource(&quot;5_85g3d&quot;)&#10;metadata/_custom_type_script = &quot;uid://d218u27sl8kf8&quot;&#10;&#10;[node name=&quot;VBoxContainer&quot; type=&quot;VBoxContainer&quot; parent=&quot;CanvasLayer/IKControlPanel&quot;]&#10;layout_mode = 0&#10;offset_right = 500.0&#10;offset_bottom = 153.0&#10;&#10;[node name=&quot;AlgorithmSelector&quot; type=&quot;OptionButton&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;JointCountLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Number of Links:&quot;&#10;&#10;[node name=&quot;JointCountSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;TargetMovementCheckBox&quot; type=&quot;CheckBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Enable Target Movement&quot;&#10;&#10;[node name=&quot;ToleranceLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;ToleranceSlider&quot; type=&quot;HSlider&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationSlider&quot; type=&quot;HSlider&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;SolveButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Solve IK&quot;&#10;&#10;[node name=&quot;NextStepButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Next Step&quot;&#10;&#10;[node name=&quot;ResetButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Reset&quot;&#10;&#10;[node name=&quot;StepInfoLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;StatsLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationLabel&quot; type=&quot;Label&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;WorldEnvironment&quot; type=&quot;WorldEnvironment&quot; parent=&quot;.&quot;]&#10;environment = SubResource(&quot;Environment_o6xl0&quot;)&#10;" />
              <option name="updatedContent" value="[gd_scene load_steps=10 format=3 uid=&quot;uid://pwcja2iwl6ej&quot;]&#10;&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://cwv0n52mn1n0k&quot; path=&quot;res://scenes/main_scene.gd&quot; id=&quot;1_tbgi4&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://cf0ebjoqwsgky&quot; path=&quot;res://core/ik_controller.gd&quot; id=&quot;2_tefeu&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://blys41lg01fyr&quot; path=&quot;res://visualization/chain_visualizer.gd&quot; id=&quot;3_o6xl0&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://bottxwpbkclic&quot; path=&quot;res://visualization/target_visualizer.gd&quot; id=&quot;4_tipki&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://d218u27sl8kf8&quot; path=&quot;res://ui/ik_control_panel.gd&quot; id=&quot;5_85g3d&quot;]&#10;[ext_resource type=&quot;Script&quot; uid=&quot;uid://ivj52hx2vhln&quot; path=&quot;res://core/ik_chain.gd&quot; id=&quot;6_tefeu&quot;]&#10;&#10;[sub_resource type=&quot;ProceduralSkyMaterial&quot; id=&quot;ProceduralSkyMaterial_tefeu&quot;]&#10;sky_top_color = Color(0.546, 0.57199997, 0.65, 1)&#10;sky_horizon_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;ground_bottom_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;ground_horizon_color = Color(0.54509807, 0.57254905, 0.6509804, 1)&#10;&#10;[sub_resource type=&quot;Sky&quot; id=&quot;Sky_tefeu&quot;]&#10;sky_material = SubResource(&quot;ProceduralSkyMaterial_tefeu&quot;)&#10;&#10;[sub_resource type=&quot;Environment&quot; id=&quot;Environment_o6xl0&quot;]&#10;background_mode = 2&#10;sky = SubResource(&quot;Sky_tefeu&quot;)&#10;ambient_light_color = Color(1, 1, 1, 1)&#10;&#10;[node name=&quot;Main&quot; type=&quot;Node3D&quot;]&#10;script = ExtResource(&quot;1_tbgi4&quot;)&#10;&#10;[node name=&quot;IKChain&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;6_tefeu&quot;)&#10;metadata/_custom_type_script = &quot;uid://ivj52hx2vhln&quot;&#10;&#10;[node name=&quot;IKController&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;2_tefeu&quot;)&#10;&#10;[node name=&quot;ChainVisualizer&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;3_o6xl0&quot;)&#10;segment_color = Color(1, 1, 0, 1)&#10;&#10;[node name=&quot;TargetVisualizer&quot; type=&quot;Node3D&quot; parent=&quot;.&quot;]&#10;script = ExtResource(&quot;4_tipki&quot;)&#10;&#10;[node name=&quot;Camera3D&quot; type=&quot;Camera3D&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;CanvasLayer&quot; type=&quot;CanvasLayer&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;IKControlPanel&quot; type=&quot;Control&quot; parent=&quot;CanvasLayer&quot;]&#10;layout_mode = 3&#10;anchors_preset = 0&#10;script = ExtResource(&quot;5_85g3d&quot;)&#10;metadata/_custom_type_script = &quot;uid://d218u27sl8kf8&quot;&#10;&#10;[node name=&quot;VBoxContainer&quot; type=&quot;VBoxContainer&quot; parent=&quot;CanvasLayer/IKControlPanel&quot;]&#10;layout_mode = 0&#10;offset_right = 500.0&#10;offset_bottom = 153.0&#10;&#10;[node name=&quot;AlgorithmSelector&quot; type=&quot;OptionButton&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;JointCountLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Number of Links:&quot;&#10;&#10;[node name=&quot;JointCountSpinBox&quot; type=&quot;SpinBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;TargetMovementCheckBox&quot; type=&quot;CheckBox&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Enable Target Movement&quot;&#10;&#10;[node name=&quot;ToleranceLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;ToleranceSlider&quot; type=&quot;HSlider&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationSlider&quot; type=&quot;HSlider&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;SolveButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Solve IK&quot;&#10;&#10;[node name=&quot;NextStepButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Next Step&quot;&#10;&#10;[node name=&quot;ResetButton&quot; type=&quot;Button&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;text = &quot;Reset&quot;&#10;&#10;[node name=&quot;StepInfoLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;StatsLabel&quot; type=&quot;Label&quot; parent=&quot;CanvasLayer/IKControlPanel/VBoxContainer&quot;]&#10;layout_mode = 2&#10;&#10;[node name=&quot;IterationLabel&quot; type=&quot;Label&quot; parent=&quot;.&quot;]&#10;&#10;[node name=&quot;WorldEnvironment&quot; type=&quot;WorldEnvironment&quot; parent=&quot;.&quot;]&#10;environment = SubResource(&quot;Environment_o6xl0&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/../scenes/main_scene.gd">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../scenes/main_scene.gd" />
              <option name="originalContent" value="## Main scene controller - orchestrates all components&#10;## Follows Dependency Inversion - depends on abstractions (IKController, visualizers)&#10;extends Node3D&#10;&#10;@onready var ik_controller: IKController = $IKController&#10;@onready var chain_visualizer: ChainVisualizer = $ChainVisualizer&#10;@onready var target_visualizer: TargetVisualizer = $TargetVisualizer&#10;@onready var camera: Camera3D = $Camera3D&#10;@onready var control_panel: IKControlPanel = $CanvasLayer/IKControlPanel&#10;&#10;var is_dragging_target: bool = false&#10;var drag_plane: Plane = Plane(Vector3.FORWARD, 0)&#10;var target_movement_enabled: bool = false&#10;&#10;func _ready() -&gt; void:&#10;&#9;setup_scene()&#10;&#9;connect_signals()&#10;&#10;func setup_scene() -&gt; void:&#10;&#9;if camera:&#10;&#9;&#9;camera.position = Vector3(0, 3, 8)&#10;&#9;&#9;camera.look_at(Vector3.ZERO, Vector3.UP)&#10;&#9;if target_visualizer and ik_controller:&#10;&#9;&#9;var initial_target: Vector3 = Vector3(2, 2, 0)&#10;&#9;&#9;target_visualizer.set_target_position(initial_target)&#10;&#10;func connect_signals() -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.algorithm_changed.connect(_on_algorithm_changed)&#10;&#9;&#9;control_panel.parameters_changed.connect(_on_parameters_changed)&#10;&#9;&#9;control_panel.reset_requested.connect(_on_reset_requested)&#10;&#9;&#9;control_panel.solve_requested.connect(_on_solve_requested)&#10;&#9;&#9;control_panel.next_step_requested.connect(_on_next_step_requested)&#10;&#9;&#9;control_panel.joint_count_changed.connect(_on_joint_count_changed)&#10;&#9;&#9;control_panel.target_movement_toggled.connect(_on_target_movement_toggled)&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.solve_completed.connect(_on_solve_completed)&#10;&#9;&#9;ik_controller.step_executed.connect(_on_step_executed)&#10;&#10;func _input(event: InputEvent) -&gt; void:&#10;&#9;if not target_movement_enabled:&#10;&#9;&#9;return&#10;&#9;if event is InputEventMouseButton:&#10;&#9;&#9;if event.button_index == MOUSE_BUTTON_LEFT:&#10;&#9;&#9;&#9;is_dragging_target = event.pressed&#10;&#9;if event is InputEventMouseMotion and is_dragging_target:&#10;&#9;&#9;move_target_with_mouse(event.position)&#10;&#10;func move_target_with_mouse(screen_pos: Vector2) -&gt; void:&#10;&#9;if not camera or not target_visualizer:&#10;&#9;&#9;return&#10;&#9;var from: Vector3 = camera.project_ray_origin(screen_pos)&#10;&#9;var direction: Vector3 = camera.project_ray_normal(screen_pos)&#10;&#9;var intersection: Variant = drag_plane.intersects_ray(from, direction)&#10;&#9;if intersection:&#10;&#9;&#9;target_visualizer.set_target_position(intersection)&#10;&#10;func _on_algorithm_changed(algorithm_name: String) -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_solver_by_name(algorithm_name)&#10;&#10;func _on_parameters_changed(max_iterations: int, tolerance: float) -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.configure_solver(max_iterations, tolerance)&#10;&#10;func _on_solve_requested() -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_step_mode(false)&#10;&#9;&#9;ik_controller.solve()&#10;&#10;func _on_reset_requested() -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_step_mode(false)&#10;&#9;&#9;ik_controller.reset_chain()&#10;&#9;if target_visualizer:&#10;&#9;&#9;target_visualizer.set_target_position(Vector3(2, 2, 0))&#10;&#10;func _on_solve_completed(_positions: Array[Vector3], iterations: int, final_error: float) -&gt; void:&#10;&#9;if control_panel and ik_controller and ik_controller.solver:&#10;&#9;&#9;control_panel.update_stats(iterations, final_error, ik_controller.solver.get_algorithm_name())&#10;&#10;func _on_next_step_requested() -&gt; void:&#10;&#9;if not ik_controller:&#10;&#9;&#9;return&#10;&#9;if not ik_controller.step_mode_enabled:&#10;&#9;&#9;ik_controller.set_step_mode(true)&#10;&#9;&#9;ik_controller.solve()&#10;&#9;ik_controller.execute_next_step()&#10;&#10;func _on_step_executed(step_info: Dictionary) -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.update_step_info(step_info)&#10;&#10;func _on_joint_count_changed(count: int) -&gt; void:&#10;&#9;if ik_controller and ik_controller.chain:&#10;&#9;&#9;ik_controller.chain.set_joint_count(count)&#10;&#9;&#9;# Recreate visualization&#10;&#9;&#9;if chain_visualizer:&#10;&#9;&#9;&#9;chain_visualizer.create_visualization()&#10;&#10;func _on_target_movement_toggled(enabled: bool) -&gt; void:&#10;&#9;target_movement_enabled = enabled&#10;" />
              <option name="updatedContent" value="## Main scene controller - orchestrates all components&#10;## Follows Dependency Inversion - depends on abstractions (IKController, visualizers)&#10;extends Node3D&#10;&#10;@onready var ik_controller: IKController = $IKController&#10;@onready var chain_visualizer: ChainVisualizer = $ChainVisualizer&#10;@onready var target_visualizer: TargetVisualizer = $TargetVisualizer&#10;@onready var camera: Camera3D = $Camera3D&#10;@onready var control_panel: IKControlPanel = $CanvasLayer/IKControlPanel&#10;&#10;var is_dragging_target: bool = false&#10;var drag_plane: Plane = Plane(Vector3.FORWARD, 0)&#10;var target_movement_enabled: bool = false&#10;&#10;func _ready() -&gt; void:&#10;&#9;setup_scene()&#10;&#9;connect_signals()&#10;&#10;func setup_scene() -&gt; void:&#10;&#9;if camera:&#10;&#9;&#9;camera.position = Vector3(0, 3, 8)&#10;&#9;&#9;camera.look_at(Vector3.ZERO, Vector3.UP)&#10;&#9;if target_visualizer and ik_controller:&#10;&#9;&#9;var initial_target: Vector3 = Vector3(2, 2, 0)&#10;&#9;&#9;target_visualizer.set_target_position(initial_target)&#10;&#10;func connect_signals() -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.algorithm_changed.connect(_on_algorithm_changed)&#10;&#9;&#9;control_panel.parameters_changed.connect(_on_parameters_changed)&#10;&#9;&#9;control_panel.reset_requested.connect(_on_reset_requested)&#10;&#9;&#9;control_panel.solve_requested.connect(_on_solve_requested)&#10;&#9;&#9;control_panel.next_step_requested.connect(_on_next_step_requested)&#10;&#9;&#9;control_panel.joint_count_changed.connect(_on_joint_count_changed)&#10;&#9;&#9;control_panel.target_movement_toggled.connect(_on_target_movement_toggled)&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.solve_completed.connect(_on_solve_completed)&#10;&#9;&#9;ik_controller.step_executed.connect(_on_step_executed)&#10;&#10;func _input(event: InputEvent) -&gt; void:&#10;&#9;if not target_movement_enabled:&#10;&#9;&#9;return&#10;&#9;if event is InputEventMouseButton:&#10;&#9;&#9;if event.button_index == MOUSE_BUTTON_LEFT:&#10;&#9;&#9;&#9;is_dragging_target = event.pressed&#10;&#9;if event is InputEventMouseMotion and is_dragging_target:&#10;&#9;&#9;move_target_with_mouse(event.position)&#10;&#10;func move_target_with_mouse(screen_pos: Vector2) -&gt; void:&#10;&#9;if not camera or not target_visualizer:&#10;&#9;&#9;return&#10;&#9;var from: Vector3 = camera.project_ray_origin(screen_pos)&#10;&#9;var direction: Vector3 = camera.project_ray_normal(screen_pos)&#10;&#9;var intersection: Variant = drag_plane.intersects_ray(from, direction)&#10;&#9;if intersection:&#10;&#9;&#9;target_visualizer.set_target_position(intersection)&#10;&#10;func _on_algorithm_changed(algorithm_name: String) -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_solver_by_name(algorithm_name)&#10;&#10;func _on_parameters_changed(max_iterations: int, tolerance: float) -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.configure_solver(max_iterations, tolerance)&#10;&#10;func _on_solve_requested() -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_step_mode(false)&#10;&#9;&#9;ik_controller.solve()&#10;&#10;func _on_reset_requested() -&gt; void:&#10;&#9;if ik_controller:&#10;&#9;&#9;ik_controller.set_step_mode(false)&#10;&#9;&#9;ik_controller.reset_chain()&#10;&#9;if target_visualizer:&#10;&#9;&#9;target_visualizer.set_target_position(Vector3(2, 2, 0))&#10;&#10;func _on_solve_completed(_positions: Array[Vector3], iterations: int, final_error: float) -&gt; void:&#10;&#9;if control_panel and ik_controller and ik_controller.solver:&#10;&#9;&#9;control_panel.update_stats(iterations, final_error, ik_controller.solver.get_algorithm_name())&#10;&#10;func _on_next_step_requested() -&gt; void:&#10;&#9;if not ik_controller:&#10;&#9;&#9;return&#10;&#9;if not ik_controller.step_mode_enabled:&#10;&#9;&#9;ik_controller.set_step_mode(true)&#10;&#9;&#9;ik_controller.solve()&#10;&#9;ik_controller.execute_next_step()&#10;&#10;func _on_step_executed(step_info: Dictionary) -&gt; void:&#10;&#9;if control_panel:&#10;&#9;&#9;control_panel.update_step_info(step_info)&#10;&#10;func _on_joint_count_changed(count: int) -&gt; void:&#10;&#9;if ik_controller and ik_controller.chain:&#10;&#9;&#9;ik_controller.chain.set_joint_count(count)&#10;&#9;&#9;# Recreate visualization&#10;&#9;&#9;if chain_visualizer:&#10;&#9;&#9;&#9;chain_visualizer.create_visualization()&#10;&#10;func _on_target_movement_toggled(enabled: bool) -&gt; void:&#10;&#9;target_movement_enabled = enabled&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/../ui/ik_control_panel.gd">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../ui/ik_control_panel.gd" />
              <option name="originalContent" value="## UI Control panel for IK visualization (Single Responsibility - UI only)&#10;class_name IKControlPanel extends Control&#10;&#10;signal algorithm_changed(algorithm_name: String)&#10;signal parameters_changed(max_iterations: int, tolerance: float)&#10;signal reset_requested()&#10;signal solve_requested()&#10;signal next_step_requested()&#10;signal joint_count_changed(count: int)&#10;signal target_movement_toggled(enabled: bool)&#10;&#10;@onready var algorithm_selector: OptionButton = $VBoxContainer/AlgorithmSelector&#10;@onready var iteration_slider: HSlider = $VBoxContainer/IterationSlider&#10;@onready var tolerance_slider: HSlider = $VBoxContainer/ToleranceSlider&#10;@onready var iteration_label: Label = $VBoxContainer/IterationLabel&#10;@onready var tolerance_label: Label = $VBoxContainer/ToleranceLabel&#10;@onready var solve_button: Button = $VBoxContainer/SolveButton&#10;@onready var reset_button: Button = $VBoxContainer/ResetButton&#10;@onready var next_step_button: Button = $VBoxContainer/NextStepButton&#10;@onready var step_info_label: Label = $VBoxContainer/StepInfoLabel&#10;@onready var stats_label: Label = $VBoxContainer/StatsLabel&#10;@onready var joint_count_label: Label = $VBoxContainer/JointCountLabel&#10;@onready var joint_count_spinbox: SpinBox = $VBoxContainer/JointCountSpinBox&#10;@onready var target_movement_checkbox: CheckBox = $VBoxContainer/TargetMovementCheckBox&#10;&#10;func _ready() -&gt; void:&#10;&#9;setup_ui()&#10;&#9;connect_signals()&#10;&#10;func setup_ui() -&gt; void:&#10;&#9;if algorithm_selector:&#10;&#9;&#9;algorithm_selector.clear()&#10;&#9;&#9;var solvers: Array = IKSolverFactory.get_available_solvers()&#10;&#9;&#9;for solver: String in solvers:&#10;&#9;&#9;&#9;algorithm_selector.add_item(solver)&#10;&#9;if iteration_slider:&#10;&#9;&#9;iteration_slider.min_value = 1&#10;&#9;&#9;iteration_slider.max_value = 100&#10;&#9;&#9;iteration_slider.value = 10&#10;&#9;&#9;update_iteration_label(10)&#10;&#9;if tolerance_slider:&#10;&#9;&#9;tolerance_slider.min_value = 0.001&#10;&#9;&#9;tolerance_slider.max_value = 1.0&#10;&#9;&#9;tolerance_slider.step = 0.001&#10;&#9;&#9;tolerance_slider.value = 0.01&#10;&#9;&#9;update_tolerance_label(0.01)&#10;&#9;if next_step_button:&#10;&#9;&#9;next_step_button.text = &quot;Next Step&quot;&#10;&#9;if step_info_label:&#10;&#9;&#9;step_info_label.text = &quot;&quot;&#10;&#9;if joint_count_label:&#10;&#9;&#9;joint_count_label.text = &quot;Number of Links:&quot;&#10;&#9;if joint_count_spinbox:&#10;&#9;&#9;joint_count_spinbox.min_value = 2&#10;&#9;&#9;joint_count_spinbox.max_value = 20&#10;&#9;&#9;joint_count_spinbox.step = 1&#10;&#9;&#9;joint_count_spinbox.value = 5&#10;&#9;if target_movement_checkbox:&#10;&#9;&#9;target_movement_checkbox.text = &quot;Enable Target Movement&quot;&#10;&#9;&#9;target_movement_checkbox.button_pressed = false&#10;&#10;func connect_signals() -&gt; void:&#10;&#9;if algorithm_selector:&#10;&#9;&#9;algorithm_selector.item_selected.connect(_on_algorithm_selected)&#10;&#9;if iteration_slider:&#10;&#9;&#9;iteration_slider.value_changed.connect(_on_iteration_changed)&#10;&#9;if tolerance_slider:&#10;&#9;&#9;tolerance_slider.value_changed.connect(_on_tolerance_changed)&#10;&#9;if solve_button:&#10;&#9;&#9;solve_button.pressed.connect(_on_solve_pressed)&#10;&#9;if next_step_button:&#10;&#9;&#9;next_step_button.pressed.connect(_on_next_step_pressed)&#10;&#9;if reset_button:&#10;&#9;&#9;reset_button.pressed.connect(_on_reset_pressed)&#10;&#9;if joint_count_spinbox:&#10;&#9;&#9;joint_count_spinbox.value_changed.connect(_on_joint_count_changed)&#10;&#9;if target_movement_checkbox:&#10;&#9;&#9;target_movement_checkbox.toggled.connect(_on_target_movement_toggled)&#10;&#10;func _on_algorithm_selected(index: int) -&gt; void:&#10;&#9;var algorithm_name: String = algorithm_selector.get_item_text(index)&#10;&#9;algorithm_changed.emit(algorithm_name)&#10;&#10;func _on_iteration_changed(value: float) -&gt; void:&#10;&#9;update_iteration_label(int(value))&#10;&#9;emit_parameters()&#10;&#10;func _on_tolerance_changed(value: float) -&gt; void:&#10;&#9;update_tolerance_label(value)&#10;&#9;emit_parameters()&#10;&#10;func _on_solve_pressed() -&gt; void:&#10;&#9;solve_requested.emit()&#10;&#10;func _on_reset_pressed() -&gt; void:&#10;&#9;reset_requested.emit()&#10;&#9;if step_info_label:&#10;&#9;&#9;step_info_label.text = &quot;&quot;&#10;&#10;func _on_next_step_pressed() -&gt; void:&#10;&#9;next_step_requested.emit()&#10;&#10;func emit_parameters() -&gt; void:&#10;&#9;if iteration_slider and tolerance_slider:&#10;&#9;&#9;parameters_changed.emit(int(iteration_slider.value), tolerance_slider.value)&#10;&#10;func update_iteration_label(value: int) -&gt; void:&#10;&#9;if iteration_label:&#10;&#9;&#9;iteration_label.text = &quot;Max Iterations: &quot; + str(value)&#10;&#10;func update_tolerance_label(value: float) -&gt; void:&#10;&#9;if tolerance_label:&#10;&#9;&#9;tolerance_label.text = &quot;Tolerance: &quot; + str(value)&#10;&#10;func update_stats(iterations: int, error: float, algorithm: String) -&gt; void:&#10;&#9;if stats_label:&#10;&#9;&#9;stats_label.text = &quot;Algorithm: %s\nIterations: %d\nError: %.4f&quot; % [algorithm, iterations, error]&#10;&#10;func update_step_info(step_info: Dictionary) -&gt; void:&#10;&#9;if step_info_label and step_info.has(&quot;description&quot;):&#10;&#9;&#9;var text: String = &quot;Step %d/%d\n%s\nError: %.4f&quot; % [&#10;&#9;&#9;&#9;step_info.get(&quot;current_step&quot;, 0),&#10;&#9;&#9;&#9;step_info.get(&quot;total_steps&quot;, 0),&#10;&#9;&#9;&#9;step_info.get(&quot;description&quot;, &quot;&quot;),&#10;&#9;&#9;&#9;step_info.get(&quot;error&quot;, 0.0)&#10;&#9;&#9;]&#10;&#9;&#9;step_info_label.text = text&#10;&#10;func _on_joint_count_changed(value: float) -&gt; void:&#10;&#9;joint_count_changed.emit(int(value))&#10;&#10;func _on_target_movement_toggled(pressed: bool) -&gt; void:&#10;&#9;target_movement_toggled.emit(pressed)&#10;&#10;" />
              <option name="updatedContent" value="## UI Control panel for IK visualization (Single Responsibility - UI only)&#10;class_name IKControlPanel extends Control&#10;&#10;signal algorithm_changed(algorithm_name: String)&#10;signal parameters_changed(max_iterations: int, tolerance: float)&#10;signal reset_requested()&#10;signal solve_requested()&#10;signal next_step_requested()&#10;signal joint_count_changed(count: int)&#10;signal target_movement_toggled(enabled: bool)&#10;&#10;@onready var algorithm_selector: OptionButton = $VBoxContainer/AlgorithmSelector&#10;@onready var iteration_slider: HSlider = $VBoxContainer/IterationSlider&#10;@onready var tolerance_slider: HSlider = $VBoxContainer/ToleranceSlider&#10;@onready var iteration_label: Label = $VBoxContainer/IterationLabel&#10;@onready var tolerance_label: Label = $VBoxContainer/ToleranceLabel&#10;@onready var solve_button: Button = $VBoxContainer/SolveButton&#10;@onready var reset_button: Button = $VBoxContainer/ResetButton&#10;@onready var next_step_button: Button = $VBoxContainer/NextStepButton&#10;@onready var step_info_label: Label = $VBoxContainer/StepInfoLabel&#10;@onready var stats_label: Label = $VBoxContainer/StatsLabel&#10;@onready var joint_count_label: Label = $VBoxContainer/JointCountLabel&#10;@onready var joint_count_spinbox: SpinBox = $VBoxContainer/JointCountSpinBox&#10;@onready var target_movement_checkbox: CheckBox = $VBoxContainer/TargetMovementCheckBox&#10;&#10;func _ready() -&gt; void:&#10;&#9;setup_ui()&#10;&#9;connect_signals()&#10;&#10;func setup_ui() -&gt; void:&#10;&#9;if algorithm_selector:&#10;&#9;&#9;algorithm_selector.clear()&#10;&#9;&#9;var solvers: Array = IKSolverFactory.get_available_solvers()&#10;&#9;&#9;for solver: String in solvers:&#10;&#9;&#9;&#9;algorithm_selector.add_item(solver)&#10;&#9;if iteration_slider:&#10;&#9;&#9;iteration_slider.min_value = 1&#10;&#9;&#9;iteration_slider.max_value = 100&#10;&#9;&#9;iteration_slider.value = 10&#10;&#9;&#9;update_iteration_label(10)&#10;&#9;if tolerance_slider:&#10;&#9;&#9;tolerance_slider.min_value = 0.001&#10;&#9;&#9;tolerance_slider.max_value = 1.0&#10;&#9;&#9;tolerance_slider.step = 0.001&#10;&#9;&#9;tolerance_slider.value = 0.01&#10;&#9;&#9;update_tolerance_label(0.01)&#10;&#9;if next_step_button:&#10;&#9;&#9;next_step_button.text = &quot;Next Step&quot;&#10;&#9;if step_info_label:&#10;&#9;&#9;step_info_label.text = &quot;&quot;&#10;&#9;if joint_count_label:&#10;&#9;&#9;joint_count_label.text = &quot;Number of Links:&quot;&#10;&#9;if joint_count_spinbox:&#10;&#9;&#9;joint_count_spinbox.min_value = 2&#10;&#9;&#9;joint_count_spinbox.max_value = 20&#10;&#9;&#9;joint_count_spinbox.step = 1&#10;&#9;&#9;joint_count_spinbox.value = 5&#10;&#9;if target_movement_checkbox:&#10;&#9;&#9;target_movement_checkbox.text = &quot;Enable Target Movement&quot;&#10;&#9;&#9;target_movement_checkbox.button_pressed = false&#10;&#10;func connect_signals() -&gt; void:&#10;&#9;if algorithm_selector:&#10;&#9;&#9;algorithm_selector.item_selected.connect(_on_algorithm_selected)&#10;&#9;if iteration_slider:&#10;&#9;&#9;iteration_slider.value_changed.connect(_on_iteration_changed)&#10;&#9;if tolerance_slider:&#10;&#9;&#9;tolerance_slider.value_changed.connect(_on_tolerance_changed)&#10;&#9;if solve_button:&#10;&#9;&#9;solve_button.pressed.connect(_on_solve_pressed)&#10;&#9;if next_step_button:&#10;&#9;&#9;next_step_button.pressed.connect(_on_next_step_pressed)&#10;&#9;if reset_button:&#10;&#9;&#9;reset_button.pressed.connect(_on_reset_pressed)&#10;&#9;if joint_count_spinbox:&#10;&#9;&#9;joint_count_spinbox.value_changed.connect(_on_joint_count_changed)&#10;&#9;if target_movement_checkbox:&#10;&#9;&#9;target_movement_checkbox.toggled.connect(_on_target_movement_toggled)&#10;&#10;func _on_algorithm_selected(index: int) -&gt; void:&#10;&#9;var algorithm_name: String = algorithm_selector.get_item_text(index)&#10;&#9;algorithm_changed.emit(algorithm_name)&#10;&#10;func _on_iteration_changed(value: float) -&gt; void:&#10;&#9;update_iteration_label(int(value))&#10;&#9;emit_parameters()&#10;&#10;func _on_tolerance_changed(value: float) -&gt; void:&#10;&#9;update_tolerance_label(value)&#10;&#9;emit_parameters()&#10;&#10;func _on_solve_pressed() -&gt; void:&#10;&#9;solve_requested.emit()&#10;&#10;func _on_reset_pressed() -&gt; void:&#10;&#9;reset_requested.emit()&#10;&#9;if step_info_label:&#10;&#9;&#9;step_info_label.text = &quot;&quot;&#10;&#10;func _on_next_step_pressed() -&gt; void:&#10;&#9;next_step_requested.emit()&#10;&#10;func emit_parameters() -&gt; void:&#10;&#9;if iteration_slider and tolerance_slider:&#10;&#9;&#9;parameters_changed.emit(int(iteration_slider.value), tolerance_slider.value)&#10;&#10;func update_iteration_label(value: int) -&gt; void:&#10;&#9;if iteration_label:&#10;&#9;&#9;iteration_label.text = &quot;Max Iterations: &quot; + str(value)&#10;&#10;func update_tolerance_label(value: float) -&gt; void:&#10;&#9;if tolerance_label:&#10;&#9;&#9;tolerance_label.text = &quot;Tolerance: &quot; + str(value)&#10;&#10;func update_stats(iterations: int, error: float, algorithm: String) -&gt; void:&#10;&#9;if stats_label:&#10;&#9;&#9;stats_label.text = &quot;Algorithm: %s\nIterations: %d\nError: %.4f&quot; % [algorithm, iterations, error]&#10;&#10;func update_step_info(step_info: Dictionary) -&gt; void:&#10;&#9;if step_info_label and step_info.has(&quot;description&quot;):&#10;&#9;&#9;var text: String = &quot;Step %d/%d\n%s\nError: %.4f&quot; % [&#10;&#9;&#9;&#9;step_info.get(&quot;current_step&quot;, 0),&#10;&#9;&#9;&#9;step_info.get(&quot;total_steps&quot;, 0),&#10;&#9;&#9;&#9;step_info.get(&quot;description&quot;, &quot;&quot;),&#10;&#9;&#9;&#9;step_info.get(&quot;error&quot;, 0.0)&#10;&#9;&#9;]&#10;&#9;&#9;step_info_label.text = text&#10;&#10;func _on_joint_count_changed(value: float) -&gt; void:&#10;&#9;joint_count_changed.emit(int(value))&#10;&#10;func _on_target_movement_toggled(pressed: bool) -&gt; void:&#10;&#9;target_movement_toggled.emit(pressed)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>